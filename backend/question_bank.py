# Question Bank - Comprehensive DSA Questions (120 questions, 15 per topic)
# This file contains the full question bank from which random subsets are selected

QUESTION_BANK = [
    # ========== Arrays & Strings (Topic 1) - 15 questions ==========
    {"id": 1, "topic_id": 1, "topic": "Arrays & Strings", "text": "What is the time complexity of finding the maximum element in an unsorted array?", "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"], "correct": 2, "difficulty": "easy"},
    {"id": 2, "topic_id": 1, "topic": "Arrays & Strings", "text": "Which technique is most efficient for finding a pair with a given sum in a sorted array?", "options": ["Nested loops", "Two pointers", "Binary search on each element", "Hashing"], "correct": 1, "difficulty": "medium"},
    {"id": 3, "topic_id": 1, "topic": "Arrays & Strings", "text": "What does the sliding window technique optimize?", "options": ["Memory usage", "Repeated calculations in contiguous subarrays", "Sorting operations", "Recursive calls"], "correct": 1, "difficulty": "medium"},
    {"id": 4, "topic_id": 1, "topic": "Arrays & Strings", "text": "Kadane's algorithm solves which problem optimally?", "options": ["Finding duplicates", "Maximum subarray sum", "Sorting an array", "Finding median"], "correct": 1, "difficulty": "medium"},
    {"id": 5, "topic_id": 1, "topic": "Arrays & Strings", "text": "What is the space complexity of creating a prefix sum array?", "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"], "correct": 2, "difficulty": "easy"},
    {"id": 6, "topic_id": 1, "topic": "Arrays & Strings", "text": "To check if a string is a palindrome, which approach is most space-efficient?", "options": ["Create a reversed copy", "Use two pointers from both ends", "Use a stack", "Use recursion"], "correct": 1, "difficulty": "easy"},
    {"id": 7, "topic_id": 1, "topic": "Arrays & Strings", "text": "What is the time complexity of inserting an element at the beginning of an array?", "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"], "correct": 2, "difficulty": "easy"},
    {"id": 8, "topic_id": 1, "topic": "Arrays & Strings", "text": "Two strings are anagrams if they:", "options": ["Have the same length", "Have the same character frequency", "Start with the same letter", "Are both palindromes"], "correct": 1, "difficulty": "easy"},
    {"id": 9, "topic_id": 1, "topic": "Arrays & Strings", "text": "The Dutch National Flag algorithm sorts an array with how many distinct values?", "options": ["2", "3", "4", "Any number"], "correct": 1, "difficulty": "medium"},
    {"id": 10, "topic_id": 1, "topic": "Arrays & Strings", "text": "What is the time complexity of the Boyer-Moore voting algorithm?", "options": ["O(n²)", "O(n log n)", "O(n)", "O(log n)"], "correct": 2, "difficulty": "medium"},
    {"id": 11, "topic_id": 1, "topic": "Arrays & Strings", "text": "To rotate an array by k positions efficiently, which technique is used?", "options": ["Bubble sort approach", "Reversal algorithm", "Merge sort approach", "Insertion approach"], "correct": 1, "difficulty": "medium"},
    {"id": 12, "topic_id": 1, "topic": "Arrays & Strings", "text": "Which data structure helps find the longest substring without repeating characters?", "options": ["Stack", "Queue", "HashMap/HashSet", "Tree"], "correct": 2, "difficulty": "hard"},
    {"id": 13, "topic_id": 1, "topic": "Arrays & Strings", "text": "What is the time complexity of KMP string matching algorithm?", "options": ["O(n*m)", "O(n+m)", "O(n²)", "O(m²)"], "correct": 1, "difficulty": "hard"},
    {"id": 14, "topic_id": 1, "topic": "Arrays & Strings", "text": "Trapping rain water problem can be solved optimally using:", "options": ["Brute force only", "Two pointers or prefix/suffix arrays", "Sorting", "Recursion only"], "correct": 1, "difficulty": "hard"},
    {"id": 15, "topic_id": 1, "topic": "Arrays & Strings", "text": "What technique is used to find the smallest window containing all characters of a pattern?", "options": ["Two pointers with HashMap", "Binary search", "Sorting", "Stack"], "correct": 0, "difficulty": "hard"},

    # ========== Linked Lists (Topic 2) - 15 questions ==========
    {"id": 16, "topic_id": 2, "topic": "Linked Lists", "text": "What is the time complexity of accessing the nth element in a singly linked list?", "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"], "correct": 2, "difficulty": "easy"},
    {"id": 17, "topic_id": 2, "topic": "Linked Lists", "text": "Floyd's Tortoise and Hare algorithm is used for:", "options": ["Sorting a linked list", "Detecting a cycle", "Reversing a list", "Merging two lists"], "correct": 1, "difficulty": "medium"},
    {"id": 18, "topic_id": 2, "topic": "Linked Lists", "text": "How many pointers are needed to reverse a singly linked list iteratively?", "options": ["1", "2", "3", "4"], "correct": 2, "difficulty": "easy"},
    {"id": 19, "topic_id": 2, "topic": "Linked Lists", "text": "What is the advantage of a doubly linked list over a singly linked list?", "options": ["Uses less memory", "Allows bidirectional traversal", "Faster insertion at head", "Simpler implementation"], "correct": 1, "difficulty": "easy"},
    {"id": 20, "topic_id": 2, "topic": "Linked Lists", "text": "To find the middle of a linked list in one pass, use:", "options": ["Count nodes first", "Slow and fast pointer technique", "Recursion", "Two separate traversals"], "correct": 1, "difficulty": "medium"},
    {"id": 21, "topic_id": 2, "topic": "Linked Lists", "text": "A circular linked list differs from a regular linked list because:", "options": ["It has no head", "The last node points to the first node", "It uses more memory", "It cannot be traversed"], "correct": 1, "difficulty": "easy"},
    {"id": 22, "topic_id": 2, "topic": "Linked Lists", "text": "Time complexity of merging two sorted linked lists is:", "options": ["O(n*m)", "O(n+m)", "O(n log n)", "O(max(n,m))"], "correct": 1, "difficulty": "medium"},
    {"id": 23, "topic_id": 2, "topic": "Linked Lists", "text": "A dummy/sentinel node in linked list operations helps:", "options": ["Speed up access", "Simplify edge cases", "Reduce memory usage", "Enable sorting"], "correct": 1, "difficulty": "medium"},
    {"id": 24, "topic_id": 2, "topic": "Linked Lists", "text": "To find the nth node from the end in one pass, use:", "options": ["Stack", "Two pointers with n-gap", "Recursion only", "Array conversion"], "correct": 1, "difficulty": "medium"},
    {"id": 25, "topic_id": 2, "topic": "Linked Lists", "text": "LRU Cache is typically implemented using:", "options": ["Array only", "Linked list only", "HashMap + Doubly linked list", "Stack + Queue"], "correct": 2, "difficulty": "hard"},
    {"id": 26, "topic_id": 2, "topic": "Linked Lists", "text": "To reverse a linked list in groups of k, what is the time complexity?", "options": ["O(n*k)", "O(n)", "O(n log k)", "O(k)"], "correct": 1, "difficulty": "hard"},
    {"id": 27, "topic_id": 2, "topic": "Linked Lists", "text": "What is the space complexity of recursive linked list reversal?", "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"], "correct": 2, "difficulty": "medium"},
    {"id": 28, "topic_id": 2, "topic": "Linked Lists", "text": "To detect the starting node of a cycle, after detecting the cycle:", "options": ["Reset one pointer to head and move both at same speed", "Double the speed of fast pointer", "Use a hash set", "Reverse the list"], "correct": 0, "difficulty": "hard"},
    {"id": 29, "topic_id": 2, "topic": "Linked Lists", "text": "Flattening a multilevel doubly linked list uses which technique?", "options": ["Sorting", "BFS", "DFS/Recursion", "Two pointers"], "correct": 2, "difficulty": "hard"},
    {"id": 30, "topic_id": 2, "topic": "Linked Lists", "text": "What is the time complexity of inserting at the head of a singly linked list?", "options": ["O(n)", "O(log n)", "O(1)", "O(n²)"], "correct": 2, "difficulty": "easy"},

    # ========== Stacks & Queues (Topic 3) - 15 questions ==========
    {"id": 31, "topic_id": 3, "topic": "Stacks & Queues", "text": "A stack follows which principle?", "options": ["FIFO", "LIFO", "Random access", "Priority based"], "correct": 1, "difficulty": "easy"},
    {"id": 32, "topic_id": 3, "topic": "Stacks & Queues", "text": "Which data structure is used for function call management in recursion?", "options": ["Queue", "Stack", "Array", "Tree"], "correct": 1, "difficulty": "easy"},
    {"id": 33, "topic_id": 3, "topic": "Stacks & Queues", "text": "A monotonic stack is useful for finding:", "options": ["Minimum element", "Next greater/smaller element", "Median", "Mode"], "correct": 1, "difficulty": "medium"},
    {"id": 34, "topic_id": 3, "topic": "Stacks & Queues", "text": "Which structure follows FIFO principle?", "options": ["Stack", "Queue", "Tree", "Heap"], "correct": 1, "difficulty": "easy"},
    {"id": 35, "topic_id": 3, "topic": "Stacks & Queues", "text": "To check balanced parentheses, which data structure is most suitable?", "options": ["Queue", "Stack", "Array", "LinkedList"], "correct": 1, "difficulty": "easy"},
    {"id": 36, "topic_id": 3, "topic": "Stacks & Queues", "text": "Implementing a queue using two stacks - what is the amortized dequeue time?", "options": ["O(n)", "O(log n)", "O(1)", "O(n²)"], "correct": 2, "difficulty": "medium"},
    {"id": 37, "topic_id": 3, "topic": "Stacks & Queues", "text": "A min-stack supports getting the minimum in:", "options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"], "correct": 2, "difficulty": "medium"},
    {"id": 38, "topic_id": 3, "topic": "Stacks & Queues", "text": "A deque allows insertion and deletion from:", "options": ["Front only", "Rear only", "Both ends", "Middle only"], "correct": 2, "difficulty": "easy"},
    {"id": 39, "topic_id": 3, "topic": "Stacks & Queues", "text": "Priority queue is typically implemented using:", "options": ["Array", "Linked list", "Heap", "Hash table"], "correct": 2, "difficulty": "medium"},
    {"id": 40, "topic_id": 3, "topic": "Stacks & Queues", "text": "Converting infix to postfix expression uses:", "options": ["Queue", "Stack", "Array", "Tree"], "correct": 1, "difficulty": "medium"},
    {"id": 41, "topic_id": 3, "topic": "Stacks & Queues", "text": "Evaluating a postfix expression uses:", "options": ["Queue", "Stack", "Two stacks", "Recursion only"], "correct": 1, "difficulty": "medium"},
    {"id": 42, "topic_id": 3, "topic": "Stacks & Queues", "text": "The largest rectangle in histogram problem uses:", "options": ["Queue", "Monotonic stack", "Binary search", "Sorting"], "correct": 1, "difficulty": "hard"},
    {"id": 43, "topic_id": 3, "topic": "Stacks & Queues", "text": "Sliding window maximum can be efficiently solved using:", "options": ["Stack", "Deque", "Array only", "Heap only"], "correct": 1, "difficulty": "hard"},
    {"id": 44, "topic_id": 3, "topic": "Stacks & Queues", "text": "What is the advantage of a circular queue over a linear queue?", "options": ["Simpler implementation", "No wasted space after dequeue", "Faster operations", "Less memory"], "correct": 1, "difficulty": "medium"},
    {"id": 45, "topic_id": 3, "topic": "Stacks & Queues", "text": "The stock span problem is efficiently solved using:", "options": ["Monotonic stack", "Queue", "Sorting", "Binary search"], "correct": 0, "difficulty": "hard"},

    # ========== Recursion & Backtracking (Topic 4) - 15 questions ==========
    {"id": 46, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "What is the base case in factorial calculation?", "options": ["n == 2", "n <= 1", "n < 0", "No base case needed"], "correct": 1, "difficulty": "easy"},
    {"id": 47, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Time complexity of naive recursive Fibonacci?", "options": ["O(n)", "O(n²)", "O(2^n)", "O(log n)"], "correct": 2, "difficulty": "medium"},
    {"id": 48, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "In backtracking, after exploring a path that fails:", "options": ["Continue forward", "Undo the last choice and try another", "Start from beginning", "Stop execution"], "correct": 1, "difficulty": "medium"},
    {"id": 49, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "How many subsets can be formed from a set of n elements?", "options": ["n", "n²", "2^n", "n!"], "correct": 2, "difficulty": "medium"},
    {"id": 50, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "The N-Queens problem is solved using:", "options": ["Dynamic programming", "Greedy algorithm", "Backtracking", "Divide and conquer"], "correct": 2, "difficulty": "medium"},
    {"id": 51, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "What happens if a recursive function has no base case?", "options": ["Faster execution", "Stack overflow", "Returns 0", "Compiles error"], "correct": 1, "difficulty": "easy"},
    {"id": 52, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Tail recursion is when the recursive call:", "options": ["Happens first", "Is the last operation", "Happens in the middle", "Is avoided"], "correct": 1, "difficulty": "medium"},
    {"id": 53, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Time complexity of generating all permutations of n elements?", "options": ["O(n)", "O(n²)", "O(n!)", "O(2^n)"], "correct": 2, "difficulty": "medium"},
    {"id": 54, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Sudoku solver uses which algorithmic paradigm?", "options": ["Greedy", "Backtracking", "Dynamic programming", "Divide and conquer"], "correct": 1, "difficulty": "medium"},
    {"id": 55, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Minimum moves to solve Tower of Hanoi with n disks?", "options": ["n", "n²", "2^n - 1", "n!"], "correct": 2, "difficulty": "medium"},
    {"id": 56, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Space complexity of recursion is primarily determined by:", "options": ["Number of variables", "Call stack depth", "Return value size", "Number of functions"], "correct": 1, "difficulty": "easy"},
    {"id": 57, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Word search in a 2D grid uses:", "options": ["Sorting", "Backtracking with DFS", "BFS only", "Dynamic programming"], "correct": 1, "difficulty": "medium"},
    {"id": 58, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "Generating all valid parentheses combinations uses:", "options": ["Sorting", "Backtracking", "Greedy", "Hash table"], "correct": 1, "difficulty": "medium"},
    {"id": 59, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "In combination sum, to avoid duplicate combinations:", "options": ["Sort and skip duplicates", "Use a hash set", "Random selection", "No technique needed"], "correct": 0, "difficulty": "hard"},
    {"id": 60, "topic_id": 4, "topic": "Recursion & Backtracking", "text": "The rat in a maze problem explores paths using:", "options": ["BFS", "DFS/Backtracking", "Dijkstra's algorithm", "Sorting"], "correct": 1, "difficulty": "medium"},

    # ========== Trees & BST (Topic 5) - 15 questions ==========
    {"id": 61, "topic_id": 5, "topic": "Trees & BST", "text": "In a BST, all nodes in the left subtree are:", "options": ["Greater than root", "Less than root", "Equal to root", "Random"], "correct": 1, "difficulty": "easy"},
    {"id": 62, "topic_id": 5, "topic": "Trees & BST", "text": "Which traversal of a BST gives nodes in sorted order?", "options": ["Preorder", "Inorder", "Postorder", "Level order"], "correct": 1, "difficulty": "easy"},
    {"id": 63, "topic_id": 5, "topic": "Trees & BST", "text": "Time complexity of search in a balanced BST?", "options": ["O(n)", "O(log n)", "O(n²)", "O(1)"], "correct": 1, "difficulty": "easy"},
    {"id": 64, "topic_id": 5, "topic": "Trees & BST", "text": "Level order traversal uses which data structure?", "options": ["Stack", "Queue", "Array", "Linked list"], "correct": 1, "difficulty": "easy"},
    {"id": 65, "topic_id": 5, "topic": "Trees & BST", "text": "Height of a tree with only the root node is:", "options": ["0", "1", "-1", "Undefined"], "correct": 0, "difficulty": "easy"},
    {"id": 66, "topic_id": 5, "topic": "Trees & BST", "text": "A complete binary tree has all levels full except:", "options": ["The root level", "The last level (filled left to right)", "The middle level", "No exceptions"], "correct": 1, "difficulty": "medium"},
    {"id": 67, "topic_id": 5, "topic": "Trees & BST", "text": "Maximum nodes in a binary tree of height h is:", "options": ["h", "2h", "2^h - 1", "2^(h+1) - 1"], "correct": 3, "difficulty": "medium"},
    {"id": 68, "topic_id": 5, "topic": "Trees & BST", "text": "Lowest Common Ancestor in a BST can be found in:", "options": ["O(n)", "O(h)", "O(n²)", "O(log n) always"], "correct": 1, "difficulty": "medium"},
    {"id": 69, "topic_id": 5, "topic": "Trees & BST", "text": "To validate if a tree is a BST, we can use:", "options": ["Level order only", "Inorder traversal (check if sorted)", "Postorder only", "Random sampling"], "correct": 1, "difficulty": "medium"},
    {"id": 70, "topic_id": 5, "topic": "Trees & BST", "text": "Diameter of a binary tree is:", "options": ["Height of the tree", "Longest path between any two nodes", "Number of leaves", "Width at the widest level"], "correct": 1, "difficulty": "medium"},
    {"id": 71, "topic_id": 5, "topic": "Trees & BST", "text": "An AVL tree is:", "options": ["An unbalanced BST", "A self-balancing BST", "A complete binary tree", "A B-tree"], "correct": 1, "difficulty": "medium"},
    {"id": 72, "topic_id": 5, "topic": "Trees & BST", "text": "Inorder successor in a BST is the:", "options": ["Parent node", "Maximum in left subtree", "Minimum in right subtree", "Root node"], "correct": 2, "difficulty": "medium"},
    {"id": 73, "topic_id": 5, "topic": "Trees & BST", "text": "To serialize a binary tree, which traversal with null markers works?", "options": ["Inorder only", "Preorder or level order with nulls", "Postorder only", "Any traversal without nulls"], "correct": 1, "difficulty": "hard"},
    {"id": 74, "topic_id": 5, "topic": "Trees & BST", "text": "Morris traversal achieves O(1) space by:", "options": ["Using recursion", "Using threaded binary tree concept", "Deleting nodes", "Level order approach"], "correct": 1, "difficulty": "hard"},
    {"id": 75, "topic_id": 5, "topic": "Trees & BST", "text": "Constructing a binary tree uniquely requires:", "options": ["Inorder alone", "Preorder alone", "Inorder with preorder or postorder", "Level order alone"], "correct": 2, "difficulty": "hard"},

    # ========== Graphs (Topic 6) - 15 questions ==========
    {"id": 76, "topic_id": 6, "topic": "Graphs", "text": "Shortest path in an unweighted graph is found using:", "options": ["DFS", "BFS", "Dijkstra", "Bellman-Ford"], "correct": 1, "difficulty": "medium"},
    {"id": 77, "topic_id": 6, "topic": "Graphs", "text": "Space complexity of an adjacency matrix is:", "options": ["O(V)", "O(E)", "O(V²)", "O(V+E)"], "correct": 2, "difficulty": "medium"},
    {"id": 78, "topic_id": 6, "topic": "Graphs", "text": "Cycle detection in a directed graph can be done using:", "options": ["BFS only", "DFS only", "Both BFS and DFS", "Neither"], "correct": 2, "difficulty": "medium"},
    {"id": 79, "topic_id": 6, "topic": "Graphs", "text": "Topological sort is applicable for:", "options": ["Any graph", "DAG (Directed Acyclic Graph) only", "Cyclic graphs", "Undirected graphs"], "correct": 1, "difficulty": "medium"},
    {"id": 80, "topic_id": 6, "topic": "Graphs", "text": "BFS uses which data structure?", "options": ["Stack", "Queue", "Priority queue", "Hash table"], "correct": 1, "difficulty": "easy"},
    {"id": 81, "topic_id": 6, "topic": "Graphs", "text": "DFS uses which data structure (or equivalent)?", "options": ["Queue", "Stack/Recursion", "Priority queue", "Heap"], "correct": 1, "difficulty": "easy"},
    {"id": 82, "topic_id": 6, "topic": "Graphs", "text": "Dijkstra's algorithm fails with:", "options": ["Dense graphs", "Sparse graphs", "Negative edge weights", "Disconnected graphs"], "correct": 2, "difficulty": "medium"},
    {"id": 83, "topic_id": 6, "topic": "Graphs", "text": "Number of edges in a complete undirected graph with V vertices:", "options": ["V", "V-1", "V(V-1)/2", "V²"], "correct": 2, "difficulty": "medium"},
    {"id": 84, "topic_id": 6, "topic": "Graphs", "text": "Union-Find data structure is used for:", "options": ["Shortest path", "Cycle detection and connected components", "Sorting", "Level order traversal"], "correct": 1, "difficulty": "medium"},
    {"id": 85, "topic_id": 6, "topic": "Graphs", "text": "Kruskal's algorithm finds:", "options": ["Shortest path", "Minimum Spanning Tree", "Topological order", "All cycles"], "correct": 1, "difficulty": "medium"},
    {"id": 86, "topic_id": 6, "topic": "Graphs", "text": "To check if a graph is bipartite, we use:", "options": ["DFS/BFS with 2-coloring", "Dijkstra", "Topological sort", "MST algorithm"], "correct": 0, "difficulty": "medium"},
    {"id": 87, "topic_id": 6, "topic": "Graphs", "text": "Time complexity of Bellman-Ford algorithm?", "options": ["O(V+E)", "O(VE)", "O(V²)", "O(E log V)"], "correct": 1, "difficulty": "medium"},
    {"id": 88, "topic_id": 6, "topic": "Graphs", "text": "Strongly connected components are found using:", "options": ["Dijkstra", "Kosaraju's or Tarjan's algorithm", "Prim's", "Kruskal's"], "correct": 1, "difficulty": "hard"},
    {"id": 89, "topic_id": 6, "topic": "Graphs", "text": "To clone a graph, we use:", "options": ["Sorting", "BFS/DFS with HashMap", "Binary search", "Dynamic programming"], "correct": 1, "difficulty": "medium"},
    {"id": 90, "topic_id": 6, "topic": "Graphs", "text": "The course schedule problem is essentially:", "options": ["Shortest path problem", "Cycle detection in directed graph", "MST problem", "Sorting problem"], "correct": 1, "difficulty": "medium"},

    # ========== Sorting (Topic 7) - 15 questions ==========
    {"id": 91, "topic_id": 7, "topic": "Sorting", "text": "Average time complexity of Quick Sort?", "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"], "correct": 1, "difficulty": "easy"},
    {"id": 92, "topic_id": 7, "topic": "Sorting", "text": "Which sorting algorithm is stable?", "options": ["Quick Sort", "Heap Sort", "Merge Sort", "Selection Sort"], "correct": 2, "difficulty": "medium"},
    {"id": 93, "topic_id": 7, "topic": "Sorting", "text": "Space complexity of Merge Sort?", "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"], "correct": 2, "difficulty": "medium"},
    {"id": 94, "topic_id": 7, "topic": "Sorting", "text": "Worst case time complexity of Quick Sort?", "options": ["O(n log n)", "O(n)", "O(n²)", "O(log n)"], "correct": 2, "difficulty": "medium"},
    {"id": 95, "topic_id": 7, "topic": "Sorting", "text": "Counting Sort is most efficient when:", "options": ["Data is random", "Range of values is small", "Data is very large", "Data is already sorted"], "correct": 1, "difficulty": "medium"},
    {"id": 96, "topic_id": 7, "topic": "Sorting", "text": "Which sorting algorithm is in-place?", "options": ["Merge Sort", "Counting Sort", "Quick Sort", "Radix Sort"], "correct": 2, "difficulty": "medium"},
    {"id": 97, "topic_id": 7, "topic": "Sorting", "text": "Heap Sort uses which data structure?", "options": ["Stack", "Queue", "Heap", "Linked list"], "correct": 2, "difficulty": "easy"},
    {"id": 98, "topic_id": 7, "topic": "Sorting", "text": "Best case time complexity of Bubble Sort?", "options": ["O(n²)", "O(n log n)", "O(n)", "O(1)"], "correct": 2, "difficulty": "easy"},
    {"id": 99, "topic_id": 7, "topic": "Sorting", "text": "Radix Sort has time complexity:", "options": ["O(n²)", "O(n log n)", "O(nk) where k is number of digits", "O(n)"], "correct": 2, "difficulty": "medium"},
    {"id": 100, "topic_id": 7, "topic": "Sorting", "text": "Which sort is NOT comparison-based?", "options": ["Merge Sort", "Quick Sort", "Counting Sort", "Heap Sort"], "correct": 2, "difficulty": "medium"},
    {"id": 101, "topic_id": 7, "topic": "Sorting", "text": "Insertion Sort is most efficient for:", "options": ["Large random data", "Nearly sorted data", "Reverse sorted data", "All cases equally"], "correct": 1, "difficulty": "medium"},
    {"id": 102, "topic_id": 7, "topic": "Sorting", "text": "Lower bound of comparison-based sorting is:", "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"], "correct": 1, "difficulty": "hard"},
    {"id": 103, "topic_id": 7, "topic": "Sorting", "text": "Shell Sort is an improvement of:", "options": ["Merge Sort", "Quick Sort", "Insertion Sort", "Heap Sort"], "correct": 2, "difficulty": "medium"},
    {"id": 104, "topic_id": 7, "topic": "Sorting", "text": "For sorting external data (larger than memory), use:", "options": ["Quick Sort", "Merge Sort (external)", "Bubble Sort", "Selection Sort"], "correct": 1, "difficulty": "hard"},
    {"id": 105, "topic_id": 7, "topic": "Sorting", "text": "Time complexity of Bucket Sort in average case?", "options": ["O(n²)", "O(n+k)", "O(n log n)", "O(n)"], "correct": 1, "difficulty": "medium"},

    # ========== Dynamic Programming (Topic 8) - 15 questions ==========
    {"id": 106, "topic_id": 8, "topic": "Dynamic Programming", "text": "Dynamic programming combines recursion with:", "options": ["Iteration", "Memoization", "Sorting", "Hashing"], "correct": 1, "difficulty": "easy"},
    {"id": 107, "topic_id": 8, "topic": "Dynamic Programming", "text": "The two main approaches to DP are:", "options": ["BFS and DFS", "Top-down and Bottom-up", "Greedy and Brute force", "Recursive and Iterative only"], "correct": 1, "difficulty": "easy"},
    {"id": 108, "topic_id": 8, "topic": "Dynamic Programming", "text": "LCS stands for:", "options": ["Longest Common Substring", "Longest Common Subsequence", "Least Common Subsequence", "Linear Common Sequence"], "correct": 1, "difficulty": "easy"},
    {"id": 109, "topic_id": 8, "topic": "Dynamic Programming", "text": "Time complexity of LCS for strings of length m and n?", "options": ["O(m+n)", "O(m*n)", "O(mn)", "O(2^(m+n))"], "correct": 2, "difficulty": "medium"},
    {"id": 110, "topic_id": 8, "topic": "Dynamic Programming", "text": "0/1 Knapsack problem is solved using:", "options": ["Greedy algorithm always", "Dynamic programming", "Divide and conquer only", "Sorting alone"], "correct": 1, "difficulty": "medium"},
    {"id": 111, "topic_id": 8, "topic": "Dynamic Programming", "text": "Fibonacci with DP (memoization) has time complexity:", "options": ["O(2^n)", "O(n)", "O(n²)", "O(log n)"], "correct": 1, "difficulty": "easy"},
    {"id": 112, "topic_id": 8, "topic": "Dynamic Programming", "text": "The climbing stairs problem is similar to:", "options": ["Factorial", "Fibonacci sequence", "Binary search", "GCD computation"], "correct": 1, "difficulty": "easy"},
    {"id": 113, "topic_id": 8, "topic": "Dynamic Programming", "text": "Optimal substructure property means:", "options": ["Random structure works", "Optimal solution is built from optimal subproblem solutions", "No subproblems exist", "Linear structure only"], "correct": 1, "difficulty": "medium"},
    {"id": 114, "topic_id": 8, "topic": "Dynamic Programming", "text": "Overlapping subproblems means:", "options": ["Problems never repeat", "Same subproblems are solved multiple times", "No subproblems exist", "All subproblems are unique"], "correct": 1, "difficulty": "medium"},
    {"id": 115, "topic_id": 8, "topic": "Dynamic Programming", "text": "Edit distance (Levenshtein) problem uses:", "options": ["Greedy approach", "2D dynamic programming", "Sorting", "BFS"], "correct": 1, "difficulty": "medium"},
    {"id": 116, "topic_id": 8, "topic": "Dynamic Programming", "text": "Coin change (minimum coins) problem is solved using:", "options": ["Greedy always", "DP", "Sorting alone", "BFS alone"], "correct": 1, "difficulty": "medium"},
    {"id": 117, "topic_id": 8, "topic": "Dynamic Programming", "text": "Longest Palindromic Subsequence is related to:", "options": ["Greedy approach", "LCS (with string and its reverse)", "Graph algorithms", "Tree traversal"], "correct": 1, "difficulty": "medium"},
    {"id": 118, "topic_id": 8, "topic": "Dynamic Programming", "text": "Matrix chain multiplication uses:", "options": ["1D DP", "2D DP", "3D DP", "Greedy approach"], "correct": 1, "difficulty": "hard"},
    {"id": 119, "topic_id": 8, "topic": "Dynamic Programming", "text": "Space optimization in DP often uses:", "options": ["More arrays", "Rolling arrays (keeping only required rows)", "Linked lists", "Trees"], "correct": 1, "difficulty": "hard"},
    {"id": 120, "topic_id": 8, "topic": "Dynamic Programming", "text": "Longest Increasing Subsequence can be optimized to:", "options": ["O(n²)", "O(n log n) using binary search", "O(n)", "O(2^n)"], "correct": 1, "difficulty": "hard"},
]
